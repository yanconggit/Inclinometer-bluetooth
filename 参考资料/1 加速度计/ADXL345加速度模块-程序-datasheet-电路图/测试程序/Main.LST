C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: E:\C\Keil_v5\C51\BIN\C51.EXE Main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2           * ADXL345模块
   3           * 
   4           * 用途：ADXL345模块IIC测试程序
   5           * 
   6           * 作者         日期        备注
   7           *      2010/12/10      新增
   8           *      2010/12/11      修改
   9           * 
  10           */
  11          
  12          #include  <REG51.H> 
  13          #include  <math.h>    //Keil library  
  14          #include  <stdio.h>   //Keil library  
  15          #include  <INTRINS.H>
  16          
  17          #define   uchar unsigned char
  18          #define   uint unsigned int 
  19          
  20          
  21          sbit    SCL=P0^6;      //IIC时钟引脚定义
  22          sbit    SDA=P0^7;      //IIC数据引脚定义
  23          
  24          
  25          #define SlaveAddress   0xA6   //定义器件在IIC总线中的从地址,根据ALT  ADDRESS地址引脚不同修改
  26                                        //ALT  ADDRESS引脚接地时地址为0xA6，接电源时地址为0x3A
  27          typedef unsigned char  BYTE;
  28          typedef unsigned short WORD;
  29          
  30          BYTE BUF[8];                         //接收数据缓存区       
  31          uchar ge,shi,bai,qian,wan;           //显示变量
  32          int  dis_data;                       //变量
  33          
  34          void delay(unsigned int k);
  35          void Init_ADXL345(void);             //初始化ADXL345
  36          
  37          void conversion(uint temp_data);
  38          
  39          void  Single_Write_ADXL345(uchar REG_Address,uchar REG_data);   //单个写入数据
  40          uchar Single_Read_ADXL345(uchar REG_Address);                   //单个读取内部寄存器数据
  41          void  Multiple_Read_ADXL345();                                  //连续的读取内部寄存器数据
  42          //------------------------------------
  43          void Delay5us();
  44          void Delay5ms();
  45          void ADXL345_Start();
  46          void ADXL345_Stop();
  47          void ADXL345_SendACK(bit ack);
  48          bit  ADXL345_RecvACK();
  49          void ADXL345_SendByte(BYTE dat);
  50          BYTE ADXL345_RecvByte();
  51          void ADXL345_ReadPage();
  52          void ADXL345_WritePage();
  53          //-----------------------------------
  54          
  55          //*********************************************************
C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 2   

  56          void conversion(uint temp_data)  
  57          {  
  58   1          wan=temp_data/10000+0x30 ;
  59   1          temp_data=temp_data%10000;   //取余运算
  60   1        qian=temp_data/1000+0x30 ;
  61   1          temp_data=temp_data%1000;    //取余运算
  62   1          bai=temp_data/100+0x30   ;
  63   1          temp_data=temp_data%100;     //取余运算
  64   1          shi=temp_data/10+0x30    ;
  65   1          temp_data=temp_data%10;      //取余运算
  66   1          ge=temp_data+0x30;  
  67   1      }
  68          
  69          /*******************************/
  70          void delay(unsigned int k)  
  71          {           
  72   1      unsigned int i,j;       
  73   1        for(i=0;i<k;i++)
  74   1        {     
  75   2        for(j=0;j<121;j++)      
  76   2        {;}}            
  77   1      }
  78                    
  79          
  80          /**************************************
  81          延时5微秒(STC90C52RC---12MHz---12T)
  82          不同的工作环境,需要调整此函数，注意时钟过快时需要修改
  83          当改用1T的MCU时,请调整此延时函数
  84          **************************************/
  85          void Delay5us()
  86          {
  87   1          _nop_();_nop_();_nop_();_nop_();
  88   1          _nop_();_nop_();_nop_();_nop_();
  89   1        _nop_();_nop_();_nop_();_nop_();
  90   1      }
  91          
  92          /**************************************
  93          延时5毫秒(STC90C52RC@12M)
  94          不同的工作环境,需要调整此函数
  95          当改用1T的MCU时,请调整此延时函数
  96          **************************************/
  97          void Delay5ms()
  98          {
  99   1          WORD n = 560;
 100   1      
 101   1          while (n--);
 102   1      }
 103          
 104          /**************************************
 105          起始信号
 106          **************************************/
 107          void ADXL345_Start()
 108          {
 109   1          SDA = 1;                    //拉高数据线
 110   1          SCL = 1;                    //拉高时钟线
 111   1          Delay5us();                 //延时
 112   1          SDA = 0;                    //产生下降沿
 113   1          Delay5us();                 //延时
 114   1          SCL = 0;                    //拉低时钟线
 115   1      }
 116          
 117          /**************************************
C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 3   

 118          停止信号
 119          **************************************/
 120          void ADXL345_Stop()
 121          {
 122   1          SDA = 0;                    //拉低数据线
 123   1          SCL = 1;                    //拉高时钟线
 124   1          Delay5us();                 //延时
 125   1          SDA = 1;                    //产生上升沿
 126   1          Delay5us();                 //延时
 127   1      }
 128          
 129          /**************************************
 130          发送应答信号
 131          入口参数:ack (0:ACK 1:NAK)
 132          **************************************/
 133          void ADXL345_SendACK(bit ack)
 134          {
 135   1          SDA = ack;                  //写应答信号
 136   1          SCL = 1;                    //拉高时钟线
 137   1          Delay5us();                 //延时
 138   1          SCL = 0;                    //拉低时钟线
 139   1          Delay5us();                 //延时
 140   1      }
 141          
 142          /**************************************
 143          接收应答信号
 144          **************************************/
 145          bit ADXL345_RecvACK()
 146          {
 147   1          SCL = 1;                    //拉高时钟线
 148   1          Delay5us();                 //延时
 149   1          CY = SDA;                   //读应答信号
 150   1          SCL = 0;                    //拉低时钟线
 151   1          Delay5us();                 //延时
 152   1      
 153   1          return CY;
 154   1      }
 155          
 156          /**************************************
 157          向IIC总线发送一个字节数据
 158          **************************************/
 159          void ADXL345_SendByte(BYTE dat)
 160          {
 161   1          BYTE i;
 162   1      
 163   1          for (i=0; i<8; i++)         //8位计数器
 164   1          {
 165   2              dat <<= 1;              //移出数据的最高位
 166   2              SDA = CY;               //送数据口
 167   2              SCL = 1;                //拉高时钟线
 168   2              Delay5us();             //延时
 169   2              SCL = 0;                //拉低时钟线
 170   2              Delay5us();             //延时
 171   2          }
 172   1          ADXL345_RecvACK();
 173   1      }
 174          
 175          /**************************************
 176          从IIC总线接收一个字节数据
 177          **************************************/
 178          BYTE ADXL345_RecvByte()
 179          {
C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 4   

 180   1          BYTE i;
 181   1          BYTE dat = 0;
 182   1      
 183   1          SDA = 1;                    //使能内部上拉,准备读取数据,
 184   1          for (i=0; i<8; i++)         //8位计数器
 185   1          {
 186   2              dat <<= 1;
 187   2              SCL = 1;                //拉高时钟线
 188   2              Delay5us();             //延时
 189   2              dat |= SDA;             //读数据               
 190   2              SCL = 0;                //拉低时钟线
 191   2              Delay5us();             //延时
 192   2          }
 193   1          return dat;
 194   1      }
 195          
 196          //******单字节写入*******************************************
 197          
 198          void Single_Write_ADXL345(uchar REG_Address,uchar REG_data)
 199          {
 200   1          ADXL345_Start();                  //起始信号
 201   1          ADXL345_SendByte(SlaveAddress);   //发送设备地址+写信号
 202   1          ADXL345_SendByte(REG_Address);    //内部寄存器地址，请参考中文pdf22页 
 203   1          ADXL345_SendByte(REG_data);       //内部寄存器数据，请参考中文pdf22页 
 204   1          ADXL345_Stop();                   //发送停止信号
 205   1      }
 206          
 207          //********单字节读取*****************************************
 208          uchar Single_Read_ADXL345(uchar REG_Address)
 209          {  uchar REG_data;
 210   1          ADXL345_Start();                          //起始信号
 211   1          ADXL345_SendByte(SlaveAddress);           //发送设备地址+写信号
 212   1          ADXL345_SendByte(REG_Address);            //发送存储单元地址，从0开始 
 213   1          ADXL345_Start();                          //起始信号
 214   1          ADXL345_SendByte(SlaveAddress+1);         //发送设备地址+读信号
 215   1          REG_data=ADXL345_RecvByte();              //读出寄存器数据
 216   1        ADXL345_SendACK(1);   
 217   1        ADXL345_Stop();                           //停止信号
 218   1          return REG_data; 
 219   1      }
 220          //*********************************************************
 221          //
 222          //连续读出ADXL345内部加速度数据，地址范围0x32~0x37
 223          //
 224          //*********************************************************
 225          void Multiple_read_ADXL345(void)
 226          {   uchar i;
 227   1          ADXL345_Start();                          //起始信号
 228   1          ADXL345_SendByte(SlaveAddress);           //发送设备地址+写信号
 229   1          ADXL345_SendByte(0x32);                   //发送存储单元地址，从0x32开始  
 230   1          ADXL345_Start();                          //起始信号
 231   1          ADXL345_SendByte(SlaveAddress+1);         //发送设备地址+读信号
 232   1         for (i=0; i<6; i++)                      //连续读取6个地址数据，存储中BUF
 233   1          {
 234   2              BUF[i] = ADXL345_RecvByte();          //BUF[0]存储0x32地址中的数据
 235   2              if (i == 5)
 236   2              {
 237   3                 ADXL345_SendACK(1);                //最后一个数据需要回NOACK
 238   3              }
 239   2              else
 240   2              {
 241   3                ADXL345_SendACK(0);                //回应ACK
C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 5   

 242   3             }
 243   2         }
 244   1          ADXL345_Stop();                          //停止信号
 245   1          Delay5ms();
 246   1      }
 247          
 248          
 249          //*****************************************************************
 250          
 251          //初始化ADXL345，根据需要请参考pdf进行修改************************
 252          void Init_ADXL345()
 253          {
 254   1         Single_Write_ADXL345(0x31,0x0B);   //测量范围,正负16g，13位模式
 255   1         Single_Write_ADXL345(0x2C,0x08);   //速率设定为12.5 参考pdf13页
 256   1         Single_Write_ADXL345(0x2D,0x08);   //选择电源模式   参考pdf24页
 257   1         Single_Write_ADXL345(0x2E,0x80);   //使能 DATA_READY 中断
 258   1         Single_Write_ADXL345(0x1E,0x00);   //X 偏移量 根据测试传感器的状态写入pdf29页
 259   1         Single_Write_ADXL345(0x1F,0x00);   //Y 偏移量 根据测试传感器的状态写入pdf29页
 260   1         Single_Write_ADXL345(0x20,0x05);   //Z 偏移量 根据测试传感器的状态写入pdf29页
 261   1      }
 262          //***********************************************************************
 263          //显示x轴
 264          void display_x()
 265          {   float temp;
 266   1          dis_data=(BUF[1]<<8)+BUF[0];  //合成数据   
 267   1        if(dis_data<0){
 268   2        dis_data=-dis_data;
 269   2          DisplayOneChar(10,0,'-');      //显示正负符号位
*** WARNING C206 IN LINE 269 OF Main.c: 'DisplayOneChar': missing function-prototype
*** ERROR C267 IN LINE 269 OF Main.c: 'DisplayOneChar': requires ANSI-style prototype
 270   2        }
 271   1        else DisplayOneChar(10,0,' '); //显示空格
 272   1      
 273   1          temp=(float)dis_data*3.9;  //计算数据和显示,查考ADXL345快速入门第4页
 274   1          conversion(temp);          //转换出显示需要的数据
 275   1          DisplayOneChar(8,0,'X');
 276   1          DisplayOneChar(9,0,':'); 
 277   1          DisplayOneChar(11,0,qian); 
 278   1          DisplayOneChar(12,0,'.'); 
 279   1          DisplayOneChar(13,0,bai); 
 280   1          DisplayOneChar(14,0,shi); 
 281   1          DisplayOneChar(15,0,' '); 
 282   1      }
 283          
 284          //***********************************************************************
 285          //显示y轴
 286          void display_y()
 287          {     float temp;
 288   1          dis_data=(BUF[3]<<8)+BUF[2];  //合成数据   
 289   1        if(dis_data<0){
 290   2        dis_data=-dis_data;
 291   2          DisplayOneChar(2,1,'-');      //显示正负符号位
 292   2        }
 293   1        else DisplayOneChar(2,1,' '); //显示空格
 294   1      
 295   1          temp=(float)dis_data*3.9;  //计算数据和显示,查考ADXL345快速入门第4页
 296   1          conversion(temp);          //转换出显示需要的数据
 297   1          DisplayOneChar(0,1,'Y');   //第1行，第0列 显示y
 298   1          DisplayOneChar(1,1,':'); 
 299   1          DisplayOneChar(3,1,qian); 
 300   1          DisplayOneChar(4,1,'.'); 
 301   1          DisplayOneChar(5,1,bai); 
C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 6   

 302   1          DisplayOneChar(6,1,shi);  
 303   1          DisplayOneChar(7,1,' ');  
 304   1      }
 305          
 306          //***********************************************************************
 307          //显示z轴
 308          void display_z()
 309          {
 310   1          float temp;
 311   1          dis_data=(BUF[5]<<8)+BUF[4];    //合成数据   
 312   1        if(dis_data<0){
 313   2        dis_data=-dis_data;
 314   2          DisplayOneChar(10,1,'-');       //显示负符号位
 315   2        }
 316   1        else DisplayOneChar(10,1,' ');  //显示空格
 317   1      
 318   1          temp=(float)dis_data*3.9;  //计算数据和显示,查考ADXL345快速入门第4页
 319   1          conversion(temp);          //转换出显示需要的数据
 320   1          DisplayOneChar(8,1,'Z');  //第0行，第10列 显示Z
 321   1          DisplayOneChar(9,1,':'); 
 322   1          DisplayOneChar(11,1,qian); 
 323   1          DisplayOneChar(12,1,'.'); 
 324   1          DisplayOneChar(13,1,bai); 
 325   1          DisplayOneChar(14,1,shi); 
 326   1          DisplayOneChar(15,1,' ');  
 327   1      }
 328          
 329          
 330          //*********************************************************
 331          //******主程序********
 332          //*********************************************************
 333          void main()
 334          { 
 335   1        uchar devid;
 336   1        delay(500);                     //上电延时    
 337   1      
 338   1        
 339   1        DisplayOneChar(0,0,'A');
 340   1        DisplayOneChar(1,0,'D'); 
 341   1        DisplayOneChar(2,0,'X'); 
 342   1        DisplayOneChar(3,0,'L'); 
 343   1        DisplayOneChar(4,0,'3'); 
 344   1        DisplayOneChar(5,0,'4');  
 345   1        DisplayOneChar(6,0,'5'); 
 346   1        
 347   1        //Init_ADXL345();                   //初始化ADXL345
 348   1        //devid=Single_Read_ADXL345(0X00);  //读出的数据为0XE5,表示正确
 349   1        while(1)                          //循环
 350   1        { 
 351   2          DisplayOneChar(0,0,'A');
 352   2          DisplayOneChar(1,0,'D'); 
 353   2          DisplayOneChar(2,0,'X'); 
 354   2          DisplayOneChar(3,0,'L'); 
 355   2          DisplayOneChar(4,0,'3'); 
 356   2          DisplayOneChar(5,0,'4');  
 357   2          DisplayOneChar(6,0,'5'); 
 358   2          
 359   2          Init_ADXL345();                   //初始化ADXL345
 360   2          devid=Single_Read_ADXL345(0X00);  //读出的数据为0XE5,表示正确
 361   2          if(devid!=0XE5)
 362   2          {     
 363   3            DisplayOneChar(8,0,'N');
C51 COMPILER V9.54   MAIN                                                                  08/25/2023 21:37:33 PAGE 7   

 364   3            DisplayOneChar(9,0,'o');    
 365   3            DisplayOneChar(10,0,' ');   
 366   3            DisplayOneChar(11,0,'F');
 367   3            DisplayOneChar(12,0,'i');
 368   3            DisplayOneChar(13,0,'n');
 369   3            DisplayOneChar(14,0,'d');   
 370   3            DisplayOneChar(15,0,'!');   
 371   3            //
 372   3            DisplayOneChar(0,1,' ');   //第1行，第0列 显示y
 373   3            DisplayOneChar(1,1,' '); 
 374   3            DisplayOneChar(2,1,' ');  
 375   3            DisplayOneChar(3,1,' '); 
 376   3            DisplayOneChar(4,1,' '); 
 377   3            DisplayOneChar(5,1,' '); 
 378   3            DisplayOneChar(6,1,' ');  
 379   3            DisplayOneChar(7,1,' ');  
 380   3            DisplayOneChar(8,1,' ');  //第0行，第10列 显示Z
 381   3            DisplayOneChar(9,1,' '); 
 382   3            DisplayOneChar(11,1,' '); 
 383   3            DisplayOneChar(12,1,' '); 
 384   3            DisplayOneChar(13,1,' '); 
 385   3            DisplayOneChar(14,1,' '); 
 386   3            DisplayOneChar(15,1,' ');       
 387   3            
 388   3          }
 389   2          else
 390   2          {     
 391   3            Multiple_Read_ADXL345();        //连续读出数据，存储在BUF中
 392   3            display_x();                    //---------显示X轴
 393   3            display_y();                    //---------显示Y轴
 394   3            display_z();                    //---------显示Z轴          
 395   3          }      
 396   2          delay(350);                     //延时  
 397   2        }
 398   1      } 

C51 COMPILATION COMPLETE.  1 WARNING(S),  1 ERROR(S)
